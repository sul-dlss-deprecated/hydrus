------------------
Versioning for Items
------------------

Notes on the flow:

  user clicks publish...
    ask user for version metadata: description and major/minor

    versionMetadata.update_current_version(:description => '', :significance => :major)
    re-generate contentMD (overwrite)
    wf = Rails.env == 'development' ? nil : assemblyWF
    close_version(
      :description         => 'blah blah',
      :significance        => :major|:minor,
      :initialize_workflow => wf)

Tests:


Issues:

  The workflow service and local development:

    - The main problem: the new versioning-aware workflow service code looks
      for objects in fedora in the -dev environment, but during local development
      the objects exist only on a developer's laptop.
  
    - The Dor::WorkflowService.archive_workflow() method (which runs when you
      try to close a version) does not succeed. It's not clear how to fix this.
      Will meet with Willy.

    - The open_new_version() method fails when it tries to initialize the
      versioningWF. This step is not really necessary, so we could add an
      option to that method (:create_wf => false) to override the behavior.

  Assembly, accessioning, and local development:

    - You can't open a new version unless an object has been accessioned.
      But this requirement is unworkable during local development. One
      solution is to add a :force option to open_new_version().

    - The close_version() method initiates the accessionWF. Hydrus
      needs the ability to initiate assemblyWF (in a deployed context)
      or nothing (during local development). This can be addressed by
      another option to close_version(:initialize_workflow => nil|'assemblyWF').

    - Before closing a version, Hydrus needs to prepare the object so that
      it will run through assemblyWF successfully. Two steps are needed:
      (1) prune the upload directory of all derivatives (those not in the
      DB table); and (2) regenerate content metadata.

    - The assemblyWF should not create derivatives for Hydrus objects.

Notes on problem related to archive_workflow()

  versionable.rb

    close_version()
      Dor::WorkflowService.archive_workflow 'dor', pid, 'versioningWF'

  workflow_service.rb

    archive_workflow(repo, druid, wf_name)
      posts to the dor services app with this url
        "/objects/#{druid}/workflows/#{wf_name}/archive"

  dor_services_app.rb

    # Here's the problem for Hydrus: the app tries to load the object from Fedora.
    # The code that does the archiving work uses that object for two bits of info:
    #   pid              # Could get that from params[:id]
    #   current_version  # No obvious solution, given current code.
    before { load_item }

    resource '/workflows/:wf_name/archive' do
      # I don't think the archiver uses the entire Fedora object, so if
      # we can get this far without loading the Fedora object we would be OK.
      archiver.archive_one_datastream 'dor', @item.pid, params[:wf_name], @item.current_version

  Ideas:

    - Modify close_version() to invoke the archiver directly, bypassing the
      workflow service and the dor services app.

    - Modify archive_workflow() to take an additional parameter (current_version)
      and modify the dor services app to take that version as a parameter.
      The call to close_version() would pass that info, and the dor services app
      wouldn't need to call load_item().

--------
Other: on deck
--------

Support user's ability to hide specific files, which has the effect of setting
publish and shelve to false in the content metadata. Offer a "Hide" checkbox
(default unchecked) next to each uploaded file. Also include an info icon with
some help text.

Support editing of published Collections. After a collection has been
published, if the user makes an edit of any kind, push it through the
accessioning pipeline again. Hydrus users won't perceive the new version, other
than via the Events log.

Set up dor_services.yml for other environments.

--------
Other: blocked, requires discussion, uncertain need, etc.
--------

rightsMD: <access> blocks should include <none/> to indicate no access. This is
sort of a pain: how important is it?

Dashboard: implement hyperlinks to items-by-status. For example, "3 published"
should be a hyperlink to the 3 published items for the applicable collection.

Embargo, visibility, and license for draft Items under scenarios when the
collection's policies are changed from varies to fixed. Current app behavior:
if the collection allows "varies", the edit UI offers widgets; otherwise, the
Item view/edit pages display the current value for the Item. The problem
scenario: if Collection changes from varies to fixed, its unpublished items
will be "stuck" at their current value -- which might or might not agree with
the new fixed value set by the collection manager.

Move Terms of Deposit acceptance pop-up so it shows (if needed) when an item is
created.

Collection Items page: Type column is temporarily commented out. Add back when
we distinguish between different item types.

Work with Willy to switch local dev environment to use a local workflow service
rather than the workflow service on sul-lyberservices-dev.

Search results page: design could use some improvement. In addition, the
page does not provide a link back to the home page.

Assess allowing collections to be opened without being published. In effect,
this would be an open, draft Collection.

Should submit_for_approval() and resubmit() send email messages?

Should the hydrus app be logging more systematically?

Implement the ability for an admin to become some other user.

Gryphondor for Hydrus, so that Hydrus objects appear in SearchWorks.
[Gryphondor might be ready to add Hydrus as a project in February.]

Create object mc322hh4254 (hydra:referencesAgreement) on hydrus-dev,
hydrus-test, and hydrus-prod. [Hannah/Lynn]

Collection create: APO.roleMetadata: set the value of <name> for the
collection-manager [waiting on LDAP].

Update SUL-chrome gem to latest Bootstrap (needed to be able to use the
unchecked checkbox icon, which is not available in our current SUL-chrome gem).
When this is done, change "icon-minus" to "icon-check-empty" in the
select_status_checkbox_icon helper method (application_helper.rb).

Upgrade to hydra-head 5.0, active-fedora 5.2, OM 1.8, Solrizer 2.0, and
Blacklight 4.0. See github.com/projecthydra/hydra-head/wiki/Migrating-to-5.0.

When we upgrade to Nokogiri 1.5.6 we might encounter some namespace gotchas
when trying to access attributes. [See email from Jon Deering.]

Update Rubydora and incorporate rollback_fixtures() into it. See
spec_helper.rb. [We are blocked by active-fedora gem restriction to to 0.5.x
series. When we ugrade active-fedora, that restriction will disappear.]

Deprecation warning: "Hydra::FileAssetsHelper has been moved". We will need to
deal with this before we move to hydra-head v5x.

The home page is producing explosive volumes of SOLR logging. This occurs
during the super() call in index() of catalog_controller.rb, which invokes a
Blacklight method that logs the entire SOLR response. A bug has been filed; in
the meantime, you can use the `rake server` task, which filters out most of the
noise. [Might be fixed when we upgrade to newer version of the hydra stack.]

XML formatting issues: (1) MODS elements should be in the default order of the
MODS spec. (2) Save the XML in some consistent pretty-print form. (3) No
useless empty elements. We attempted to make some improvement to descMetadata
using the beautify_datastream() and add_hydrus_next_sibling_node() methods;
however, the former method led to some strange behavior (for example, note the
failure of `rails runner devel/create_test_item.rb batch co i`). Further
progress probably requires some planning/discussion. The existing hydra-OM
stack does not make it easy to address all of the concerns, and several DLSS
developers expressed skepticism about the wisdom of the endeavor. If this is
truly a requirement, we should to decide the most practical place to implement
such behavior -- in every application or in a single XML-cleanup gem that all
applications could invoke.

Consider moving the actual collection-depositor roleMD info from the APO to the
Collection, for two reasons: (1) it parallels the roleMD stored in the Item;
(2) without it, we don't have access to the collection depositor during search
results (at least not without mucking with the to_solr method, which we have
done in the roleMD class).
