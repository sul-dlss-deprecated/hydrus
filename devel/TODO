------------------
Development Tasks - 14 November 2012
------------------

Collection edit page, license: if user chooses varies or required but forgets
to select something from the drop-down, the app needs to refuse to save.
Otherwise, an exception is thrown when trying to render the view page --
specifically, GenericObject.license_type(code) will be called with a nil code.
[Bug reported on hydrus-test by Hannah; the exception can be seen in the log].

Support delete of a file in an unpublished item.

Terms of Deposit: create PDF and tie to save action in popup window.

Keywords: require at least one.

System integration work. Details in separate section below.

Dates and times: rationalize and centralize time logic in a module. Use iso8601
(UTC) for back-end storage, and Pacific zone for UI display. Details in a
separate section below.  [Monty]

Protect actions at the model level. This is mostly done, but a few actions remain.
Details in a separate section below. [Monty]

--------
System integration
--------

Hydrus objects end up with 2 values for submitted_dt and published_dt, because
two WFs are using the those lifecycles. [Waiting on new dor-services gem.]

Try to use hydrus-prod. [Waiting on new dor-services gem in production.]

Set up Camel to send messages to hydrus-prod. [Waiting until we start running
the app on hydrus-prod.]

--------
Protect actions at the model level
--------

# Collection.create
# Will need to make cannot_do() callable by Collection class.
cannot_do(:create) unless Hydrus::Authorizable.can_create_collections(user)

# Item.create
coll.cannot_do(:create_item_in) unless coll.is_open()

# Item:
accept_terms_of_deposit()

# HydrusSolrController
# These guarded by Tomcat rules in our Puppet manifest.
Tighten up the restrictions: replace su_admin_nets with $foz_all_nets.

--------
Other
--------

Rake task to list all Hydrus pids, along with their has_model_s value.

Create a view for hydrus admin users to list all collections, regardless of
roleMD.

Move Terms of Deposit acceptance pop-up so it shows (if needed) when an item is
created.

Desc metadata: remove emtpy stuff and improve formatting. [Waiting on details
from Hannah]

Assess allowing collections to be opened without being published. In effect,
this would be an open, draft Collection.

After a collection has been published, is it editable? If so, do we need to
push it through the accessioning pipeline again?

Gryphondor for Hydrus objects.

Update to Rubydora 0.6.0, which might speed up integration tests. [We are
blocked by dor-services gem restriction, which seems too strict. Speak with Jon
D.]

Should submit_for_approval() and resubmit() send email messages?

Remove all code that puts WF into the APO. Search for workflow_steps.

After finishing more thorough UI rework, look at: responsiveness issues;
accessibility issues.

Update search results page; UI redesign degraded formatting of it.

Views and controllers: rename @document_fedora to something more compact.

Update SUL-chrome gem to latest Bootstrap (needed to be able to use the
unchecked checkbox icon, which is not available in our current SUL-chrome gem).
When this is done, change "icon-minus" to "icon-check-empty" in the
select_status_checkbox_icon helper method (application_helper.rb).

Refactor and write tests for redirect_if_not_correct_object_type: seems more
complex than it needs to be.

Disable edit tab for published items. NOTE: this already happens automatically
when not in development mode.

Refactor purl_page_ready() to use workflow_ds_extension. We could ask the PURL
app directly: it returns a 404 (according to Chris J) if you ask for an object
that is not known it its document cache.

Move tests for workflow_ds_extension out of gen_obj_spec and into its own spec.

Stub out workflow calls in unit and integration tests that create objects with
the "fake" PID, so that we don't run into random test failures. Step 1:
identify methods that advance the workflow (publish and its cousins). Step 2:
identify tests that invoke those methods in a non-druid-minting context.

rightsMD: Refactor to take better advantage of OM and generic_ds.rb.

Consider moving the actual collection-depositor roleMD info from the APO to the
Collection, for two reasons: (1) it parallels the roleMD stored in the Item;
(2) without it, we don't have access to the collection depositor during search
results (at least not without mucking with the to_solr method).

Collection Items page: Type column is temporarily commented out. Add back when
we distinguish between different item types.

Work with Willy to switch local dev environment to use a local workflow service
rather than the workflow service on sul-lyberservices-dev.

Should the hydrus app be logging more systematically?

Dashboard: implement hyperlinks to items-by-status. For example, "3 published"
should be a hyperlink to the 3 published items for the applicable collection.

Collection/Item create. Rather than starting a new Item/Collection with blank
text boxes, use the approach we have adopted elsewhere for non-required items:
have the user click "Add" button first. Collection: links to related items.
Item: related citations; and links to related items.

Consider moving Hydrus::Responsible into RoleMDDS. Not sure that we need the
module. Also, there is currently some duplication between Hydrus::Responsible
and the to_solr() method in RoleMDDS.

APO RELS-EXT datastream needs to add a child node to <rdf:Description>:
<hydra:referencesAgreement rdf:resource="info:fedora/druid:XXX"/>, where XXX is
the PID of the global Hydrus Agreement object. [The Hydrus agreement object
needs to be created -- need more details].

Collection create: APO.roleMetadata: set the value of <name> for the
collection-manager [waiting on LDAP].

Item view page: the actions box div is called "div.collection-actions".  Is
this a problem?

The home page is producing explosive volumes of SOLR logging. This occurs
during the super() call in index() of catalog_controller.rb, which invokes a
Blacklight method that logs the entire SOLR response. A bug has been filed; in
the meantime, you can use the `rake server` task, which filters out most of the
noise.

------------------
DateTime rationalization
------------------

Create a module to centralize time-related functionality.

  module HyTime

    self.local_timezone
      return 'Pacific Time (US & Canada)'

    self.formatted(dt, opts = {})
      # Takes a String or DateTime.
      f = (opts[:format] || :datetime)
      p = (opts[:parse]  || :datetime)

      # Convert the argument to a DateTime object, if needed.
      dt = parse(dt, p) if dt.class == String

      # Adjust to local timezone if using a display format.
      dt = dt.in_time_zone(local_timezone) if f.to_s[-5..-1] == '_disp'

      # Return string in the requested format.
      return dt.strftime(formats(f))

    self.parse(s, format = :datetime)
      return DateTime.strptime(dt, format)

    self.formats(k)
      # Takes a key and returns a datetime format string.

      # Back-end formats for storage are based on iso8601: "2012-11-16T23:40:11Z".
      :date              => '%F'
      :time              => '%T',
      :datetime          => '%FT%TZ',    # Same as calling iso8601() on a DateTime.
      :datetime_m        => '%FT%T.%LZ',

      # Front-end formats for display.
      # Same as back-end formats for now.
      # Might need to modify some fixtures.
      # Might need to modify what the UI returns from date picker or use :mdy below.
      :date_disp
      :time_disp
      :datetime_disp
      :mdy_disp       # mm/dd/yyyy From UI?

    self.now()
      return DateTime.now.in_time_zone

    # Methods generated for each key from self.formats().
    self.now_FOO
      return formatted(now, :format => FOO)

      # Example usages.
      self.publish_time = HyTime.now_datetime   # String for XML.
      <%= HyTime.now_date_disp >                # String for the UI.

Usages:

  app/helpers/application_helper.rb
    hydrus_format_date(input_string)
    formatted_datetime(datetime, k = :datetime)
    datetime_format(k)

  app/models/hydrus/collection.rb
    self.publish_time = Time.now.in_time_zone.to_s
    accept_terms_of_deposit(user,date_accepted)

  app/models/hydrus/generic_object.rb
    self.last_modify_time = Time.now.in_time_zone.to_s
    tm   = Time.now.in_time_zone.strftime('%Y-%m-%d %H:%M:%S.%L %z')  # With milliseconds.

  app/models/hydrus/item.rb
    Time.now.in_time_zone.to_s
    Time.now.in_time_zone.to_s
    Time.now.in_time_zone.to_s
    Time.now.in_time_zone - 1.year
    Time.now.in_time_zone
    Date.parse(publish_time).strftime("%m/%d/%Y")
    Date.today.strftime("%m/%d/%Y")
    (Date.strptime(beginning_of_embargo_range, "%m/%d/%Y") + number.send(increment)).strftime("%m/%d/%Y")
    Date.strptime(embargo_date, "%m/%d/%Y").to_s
    unless (Date.strptime(beginning_of_embargo_range, "%m/%d/%Y")...Date.strptime(end_of_embargo_range, "%m/%d/%Y")).include?(Date.strptime(embargo_date, "%m/%d/%Y"))

  app/models/hydrus/properties_settable.rb
    Date.strptime(embargo_date, "%m/%d/%Y")
    Date.parse(date).strftime("%m/%d/%Y") 
    Date.strptime(val, "%m/%d/%Y").to_s

  app/views/events/index.html.erb
    formatted_datetime(event.when, :datetime)

  app/views/hydrus_items/_basic_item_metadata.html.erb
    hydrus_format_date: several

  app/views/hydrus_items/index.html.erb
    hydrus_format_date(item.create_date)

  app/views/hydrus_mailer/error_notification.html.erb
    Time.now.in_time_zone

  config/application.rb
    config.time_zone = 'UTC'

  test/fixtures/object_files.yml
    Several uses of Time.now

  spec/fixtures
    Several datetimes as strings. Check the ones we care about.

  spec/integration/item_create_spec.rb
    (Time.now.in_time_zone - 1.month).to_s

  spec/models/hydrus/item_spec.rb
    several examples along these lines:
      (Date.today + 2.days).strftime("%m/%d/%Y")
      Date.today.strftime("%m/%d/%Y")
      Date.strptime("08/01/2012", "%m/%d/%Y").to_s
